package designpattern.decoratorpattern.prototype;

/**
 * 组件
 * 装饰者模式 为设计注入弹性
 * 因为小类太多，导致别人不容易了解 设计方式
 * 客户代码中如果依赖某种特殊类型，导入装饰者，不周详考虑，会出问题
 * 使用装饰者，在实例化组件时，会增加代码复杂度
 * 装饰者模式是第一个符合开放-关闭原则的模式
 * 动态低将责任附加到对象上，提供了有别于继承的扩展功能的选择
 * 特点： 具有相同的类型，通过接口或继承实现
 * 装饰者甚至可以将被装饰者的行为整个取代掉，从而达到特定的目的
 * 装饰者一般对组件时透明的，除非客户程序依赖组件的具体类型
 * 如果过度使用，程序会变复杂
 */
class Component {

    void methodA() {
    }

    void methodB() {
    }
}
